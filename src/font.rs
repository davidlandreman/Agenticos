use core::str;

// Default 8x8 font data for ASCII characters 32-126 (space to tilde)
pub const DEFAULT_8X8_FONT_DATA: [[u8; 8]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ' ' (space)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // '!'
    [0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00], // '"'
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00], // '#'
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00], // '$'
    [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00], // '%'
    [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00], // '&'
    [0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // '\''
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // '('
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // ')'
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // '*'
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // '+'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // ','
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // '-'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // '.'
    [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00], // '/'
    [0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00], // '0'
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // '1'
    [0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0xFE, 0x00], // '2'
    [0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00], // '3'
    [0x0C, 0x1C, 0x3C, 0x6C, 0xFE, 0x0C, 0x0C, 0x00], // '4'
    [0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00], // '5'
    [0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00], // '6'
    [0xFE, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x00], // '7'
    [0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00], // '8'
    [0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00], // '9'
    [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00], // ':'
    [0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30], // ';'
    [0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00], // '<'
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00], // '='
    [0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00], // '>'
    [0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00], // '?'
    [0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00], // '@'
    [0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00], // 'A'
    [0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00], // 'B'
    [0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00], // 'C'
    [0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00], // 'D'
    [0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00], // 'E'
    [0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00], // 'F'
    [0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00], // 'G'
    [0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00], // 'H'
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // 'I'
    [0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00], // 'J'
    [0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00], // 'K'
    [0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00], // 'L'
    [0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00], // 'M'
    [0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00], // 'N'
    [0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00], // 'O'
    [0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00], // 'P'
    [0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00], // 'Q'
    [0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00], // 'R'
    [0x78, 0xCC, 0xE0, 0x70, 0x1C, 0xCC, 0x78, 0x00], // 'S'
    [0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00], // 'T'
    [0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xFC, 0x00], // 'U'
    [0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00], // 'V'
    [0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00], // 'W'
    [0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00], // 'X'
    [0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00], // 'Y'
    [0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00], // 'Z'
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00], // '['
    [0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00], // '\\'
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00], // ']'
    [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00], // '^'
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF], // '_'
    [0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00], // '`'
    [0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00], // 'a'
    [0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00], // 'b'
    [0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00], // 'c'
    [0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00], // 'd'
    [0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00], // 'e'
    [0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00], // 'f'
    [0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8], // 'g'
    [0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00], // 'h'
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // 'i'
    [0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C], // 'j'
    [0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00], // 'k'
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // 'l'
    [0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00], // 'm'
    [0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00], // 'n'
    [0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00], // 'o'
    [0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0], // 'p'
    [0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E], // 'q'
    [0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00], // 'r'
    [0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00], // 's'
    [0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00], // 't'
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00], // 'u'
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00], // 'v'
    [0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00], // 'w'
    [0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00], // 'x'
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8], // 'y'
    [0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00], // 'z'
    [0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00], // '{'
    [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00], // '|'
    [0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00], // '}'
    [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // '~'
];

// Create a static instance of the default 8x8 font
pub static DEFAULT_8X8_FONT: Embedded8x8Font = Embedded8x8Font {
    first_char: 32,  // ASCII space
    num_chars: 95,   // space to tilde
    font_data: &DEFAULT_8X8_FONT_DATA,
};

#[derive(Debug, Clone, Copy)]
pub struct CharInfo {
    pub id: u16,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub xoffset: i16,
    pub yoffset: i16,
    pub xadvance: i16,
    pub page: u8,
}

#[derive(Debug)]
pub struct BMFont {
    pub line_height: u16,
    pub base: u16,
    pub scale_w: u16,
    pub scale_h: u16,
    pub chars: [Option<CharInfo>; 256],
    pub char_count: usize,
    pub texture_data: &'static [u8],
}

// VFNT format structure for embedded bitmap fonts
#[derive(Debug)]
pub struct VFNTFont {
    pub width: u8,
    pub height: u8,
    pub first_char: u8,
    pub num_chars: u8,
    pub bitmap_data: &'static [u8],
}

// Embedded 8x8 font structure
#[derive(Debug)]
pub struct Embedded8x8Font {
    pub first_char: u8,
    pub num_chars: u8,
    pub font_data: &'static [[u8; 8]],
}

impl Embedded8x8Font {
    pub fn get_char_bitmap(&self, ch: char) -> Option<&[u8; 8]> {
        let char_code = ch as u8;
        if char_code < self.first_char || char_code >= self.first_char + self.num_chars {
            return None;
        }
        
        let char_index = (char_code - self.first_char) as usize;
        if char_index < self.font_data.len() {
            Some(&self.font_data[char_index])
        } else {
            None
        }
    }
}

impl VFNTFont {
    pub fn from_vfnt_data(data: &'static [u8]) -> Option<Self> {
        // Check for VFNT header
        if data.len() < 12 || &data[0..4] != b"VFNT" {
            return None;
        }
        
        // Check version string "0002"
        if &data[4..8] != b"0002" {
            return None;
        }
        
        // Parse font properties at offset 8
        let width = data[8];
        let height = data[9];
        let first_char = data[10];
        let num_chars = data[11];
        
        // VFNT header appears to be variable, but bitmap data starts after header
        // Let's scan for where the actual bitmap data starts
        let header_size = 128; // Standard header size
        
        // Calculate expected data size
        let bytes_per_char = ((width as usize + 7) / 8) * height as usize;
        let _bitmap_size = num_chars as usize * bytes_per_char;
        
        if data.len() < header_size {
            return None;
        }
        
        Some(Self {
            width,
            height,
            first_char,
            num_chars,
            bitmap_data: &data[header_size..],
        })
    }
    
    pub fn get_char_bitmap(&self, ch: char) -> Option<&[u8]> {
        let char_code = ch as u8;
        if char_code < self.first_char || char_code >= self.first_char + self.num_chars {
            return None;
        }
        
        let char_index = (char_code - self.first_char) as usize;
        let bytes_per_row = (self.width as usize + 7) / 8;
        let bytes_per_char = bytes_per_row * self.height as usize;
        let offset = char_index * bytes_per_char;
        
        if offset + bytes_per_char <= self.bitmap_data.len() {
            Some(&self.bitmap_data[offset..offset + bytes_per_char])
        } else {
            None
        }
    }
}

impl BMFont {
    pub fn from_text_format(fnt_data: &'static str, texture_data: &'static [u8]) -> Option<Self> {
        let mut font = BMFont {
            line_height: 0,
            base: 0,
            scale_w: 0,
            scale_h: 0,
            chars: [None; 256],
            char_count: 0,
            texture_data,
        };

        for line in fnt_data.lines() {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }

            let mut parts_count = 0;
            let parts: [&str; 32] = {
                let mut arr = [""; 32];
                for part in line.split_whitespace() {
                    if parts_count < 32 {
                        arr[parts_count] = part;
                        parts_count += 1;
                    }
                }
                arr
            };
            if parts_count == 0 {
                continue;
            }

            match parts[0] {
                "common" => {
                    for i in 1..parts_count {
                        let part = parts[i];
                        if let Some(eq_idx) = part.find('=') {
                            let key = &part[..eq_idx];
                            let value = &part[eq_idx + 1..];
                            match key {
                                "lineHeight" => font.line_height = parse_u16(value).unwrap_or(0),
                                "base" => font.base = parse_u16(value).unwrap_or(0),
                                "scaleW" => font.scale_w = parse_u16(value).unwrap_or(0),
                                "scaleH" => font.scale_h = parse_u16(value).unwrap_or(0),
                                _ => {}
                            }
                        }
                    }
                }
                "char" => {
                    let mut char_info = CharInfo {
                        id: 0,
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                        xoffset: 0,
                        yoffset: 0,
                        xadvance: 0,
                        page: 0,
                    };

                    for i in 1..parts_count {
                        let part = parts[i];
                        if let Some(eq_idx) = part.find('=') {
                            let key = &part[..eq_idx];
                            let value = &part[eq_idx + 1..];
                            match key {
                                "id" => char_info.id = parse_u16(value).unwrap_or(0),
                                "x" => char_info.x = parse_u16(value).unwrap_or(0),
                                "y" => char_info.y = parse_u16(value).unwrap_or(0),
                                "width" => char_info.width = parse_u16(value).unwrap_or(0),
                                "height" => char_info.height = parse_u16(value).unwrap_or(0),
                                "xoffset" => char_info.xoffset = parse_i16(value).unwrap_or(0),
                                "yoffset" => char_info.yoffset = parse_i16(value).unwrap_or(0),
                                "xadvance" => char_info.xadvance = parse_i16(value).unwrap_or(0),
                                "page" => char_info.page = parse_u8(value).unwrap_or(0),
                                _ => {}
                            }
                        }
                    }

                    if char_info.id < 256 {
                        font.chars[char_info.id as usize] = Some(char_info);
                        font.char_count += 1;
                    }
                }
                _ => {}
            }
        }

        if font.char_count > 0 && font.line_height > 0 {
            Some(font)
        } else {
            None
        }
    }

    pub fn get_char(&self, ch: char) -> Option<&CharInfo> {
        let char_code = ch as usize;
        if char_code < 256 {
            self.chars[char_code].as_ref()
        } else {
            None
        }
    }
}

// Simple parsing functions for no_std environment
fn parse_u16(s: &str) -> Option<u16> {
    let mut result = 0u16;
    for ch in s.chars() {
        if let Some(digit) = ch.to_digit(10) {
            result = result.wrapping_mul(10).wrapping_add(digit as u16);
        } else {
            return None;
        }
    }
    Some(result)
}

fn parse_i16(s: &str) -> Option<i16> {
    let mut chars = s.chars();
    let first_char = chars.next()?;
    
    let (negative, mut result) = if first_char == '-' {
        (true, 0i16)
    } else if let Some(digit) = first_char.to_digit(10) {
        (false, digit as i16)
    } else {
        return None;
    };
    
    for ch in chars {
        if let Some(digit) = ch.to_digit(10) {
            result = result.wrapping_mul(10).wrapping_add(digit as i16);
        } else {
            break;
        }
    }
    
    Some(if negative { -result } else { result })
}

fn parse_u8(s: &str) -> Option<u8> {
    let mut result = 0u8;
    for ch in s.chars() {
        if let Some(digit) = ch.to_digit(10) {
            result = result.wrapping_mul(10).wrapping_add(digit as u8);
        } else {
            return None;
        }
    }
    Some(result)
}